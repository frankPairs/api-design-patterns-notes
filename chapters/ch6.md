## Chapter 6 - Resource identification

- An identifier is used to get a specific resource from a collection of them.
- Properties of a good identifier:
  - **Easy to use**. It can be used as a part of a url, so it takes into account some restrictions (for example, it can't contains slashes)
  - **Unique**. It should be unique in the system. If it is necessary, it could be necessary to make it globally unique althogh those situations are very rare and they require a more complex algorithms.
  - **Permanent**. It should always belong to the same resource. When a resource is removed from the DB, it should not be possible to same its identifier for another one. Like legendary NBA players, their numbers cannot be used anymore after their retirement.
  - **Unpredictable**. It should not use incremental numbers as makes it predicatable for potential attackers. UUIDs, ISBN (for books), or Crackford Base32 can help to make identifiers much more difficult to predict.
  - **Readable, sharable and verifiable**. It should be easy for a user to share it or copy/paste from any device (desktop, mobile phone, or tablet).
  - **Informationally dense**. It should save as much information as into very small space (max. 64 bits)
- How an identifier should look like?:
  - It is an string because string data type provides the highest information density and it makes them easy to use, read and share.
  - Its char encoding format is ASCII. It is better than Unicode because it is more predictable (Unicode allows more than one way to represent the same chunk of text).
  - Its serialization format is Crockford's Base32 as include all the characters to make an identifier readable (a-z, A-Z, 0-9) and a lot of special characters are not part of the format (like slashes).
  - It includes a Checksum. A Checkum is a concatenation of characters that allows us to perform integrity checks. Including them at the end of an indentifier provides us a mechanism to know if the identifier is valid.
  - It represents a specific resource. The most common way to do it is by adding a the resource type separate by a slash (```api/books/abcde-12345-ghjkm-67890```).
  - It could represent a hierarchy relationship between two resources. The child of that relation can only be identify from its parent. For example, if we have a resource called Book an another one called Page where a Book is the **owner** of multiple pages, this would be the way to get a page from a book ```api/books/abcde-12345-ghjkm-67890/pages/2```. It should not be possible to identify a page without specifing its book.
- Identifiers should be generated by the API in order to avoid potential problems like predicability, id collisions or security issues. Although in some situations, it could be convenient or necessary creating them from to the clients. For example, when using a replace standard method (we will talk more about it later).
- They should not be repeated and that applies for removed resources. This requirement can be achieved by:
  - Following a soft delete strategy.
  - Saving all generated ids in a hash map and check them before creation.
- Database storage:
  - In most NoSQL databases, indexing a string field is very fast, so it is perfectly find to save identifiers as string data types.
  - In relational databases, indexing numbers is usually faster than strings. An option could be save an 32/64 bits number although some relational databases work very well with UUIDs identifiers.
- Why not using UUIDs?
  - Very large (128 bits).
  - Less readable and sharable than format like Crockford's Base32.
  - No checksum, although is something we always can add.